#pragma config(Hubs, S1, HTMotor, HTMotor, HTServo, HTMotor)
#pragma config(Sensor, S1, , sensorI2CMuxController)
#pragma config(Sensor, S2, gyro, sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3, ir, sensorHiTechnicIRSeeker1200)
#pragma config(Motor, mtr_S1_C1_1, right, tmotorTetrix, openLoop)
#pragma config(Motor, mtr_S1_C1_2, left, tmotorTetrix, openLoop, reversed)
#pragma config(Motor, mtr_S1_C2_1, motorF, tmotorTetrix, openLoop)
#pragma config(Motor, mtr_S1_C2_2, motorG, tmotorTetrix, openLoop)
#pragma config(Motor, mtr_S1_C4_1, slide, tmotorTetrix, openLoop)
#pragma config(Motor, mtr_S1_C4_2, intake, tmotorTetrix, openLoop)
#pragma config(Servo, srvo_S1_C3_1, gripper, tServoStandard)
#pragma config(Servo, srvo_S1_C3_2, servo2, tServoNone)
#pragma config(Servo, srvo_S1_C3_3, servo3, tServoNone)
#pragma config(Servo, srvo_S1_C3_4, servo4, tServoNone)
#pragma config(Servo, srvo_S1_C3_5, servo5, tServoNone)
#pragma config(Servo, srvo_S1_C3_6, servo6, tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard !!*//

/*
|
|		 _____ _____  _   _   ___  _____ _   _  ______ _   ______
|		|____ /  __ \| | | | / _ \|_   _| \ | ||___  /| | |___  /
|		    / / /  \/| |_| |/ /_\ \ | | |  \| |   / // __)   / /
|		    \ \ |    		|  _  ||  _  | | | | . ` |  / / \__ \  / /
|		.___/ / \__/\| | | || | | |_| |_| |\  |./ /__(   /./ /___
|		\____/ \____/\_| |_/\_| |_/\___/\_| \_/\_____/|_| \_____/
|
|		Team: Cobalt Colts 6547 Â© 2014-15
|		Head Tele-Op Programmer: Ryan Pope
|		Head Autonomous Programmer: Ethan Tucker
|
|			How to Drive the Robot
|			----------------------
|
|		Left Joystick Up/Down = Left Motor Speed on curve
|		Right Joystick Up/Down = Right Motor Speed on curve
|
|		Left Bumper lifts the linear slide
|		Right Bumper lowers the linear slide
|
|		Left Trigger rotates intake system into the robot
|		Right Trigger rotates intake system out of the robot
|
|		Up on D-Pad turns on gyro stabilization
|
*/

//	Joystick code
#include "JoystickDriver.c"
//	Some stuff I need a little bit
#include "ryan.h"

/*
| ------------------------------------------------------------------------------
| Controller buttons
| ------------------------------------------------------------------------------
*/
int x = 1; int a = 2; int b = 3; int y = 4; /* Buttons */
int leftBumper = 5; int rightBumper = 6; /* bumpers */
int leftTrigger = 7; int rightTrigger = 8; /* triggers */
int lastJoyVal = 0; int cycles = 0;/* anti-stall */


//	Does some gyro stuff; Don't ask
bool gyroed;


//turn the robot in a number of degrees
void turnDegrees(tSensors gyro, tMotor side, int degrees, int power)
{
	motor[side] = power;
	while(degrees > 0)
	{
		wait1Msec(1000);
		int rate = SensorValue(gyro) - offset;
		degrees -= abs(rate);
	}
	motor[side] = 0;
}

task main()
{
	//	Some kind of gyro sensor calibration
	calibrateGyro(gyro);

	while(true)
	{
		//	Update joystick values
		getJoystickSettings(joystick);

		//	Drive code
		motor[left] = speedCurve(joystick.joy1_y2);
		motor[right] = speedCurve(joystick.joy1_y1);
		//motor[slide] = speedCurve(joystick.joy1_y1) / 2;
		//motor[intake] = speedCurve(joystick.joy1_y2) / 2;
		//	Bumper controls for linear slides
		if(joy1Btn(5))
		{
			motor[slide] = 75;
		}
		else if(joy1Btn(6))
		{
			motor[slide] = -75;
		}
		else
		{
			motor[slide] = 0;
		}

		//	Trigger controls for intake systems
		if(joy1Btn(7))
		{
			if (motor[intake] == 100)
			{
				motor[intake] = 0;
			}
			else
			{
				motor[intake] = 100;
			}
			wait1Msec(100);
		}

		if(joy1Btn(8))
		{
			if (motor[intake] == -50)
			{
				motor[intake] = 0;
			}
			else
			{
				motor[intake] = -50;
			}
			wait1Msec(100);
		}

		if(joy1Btn(3))
		{
			
		}
		
		if(joystick.joy1_TopHat == 0)
		{
			motor[right] = 75;
			motor[left] = 75;
		}

		//	Turn on the gyro stabilization, ask Ethan
		while(joystick.joy1_TopHat == 0)
		{
			getJoystickSettings(joystick);
			if(SensorValue(gyro) > offset)	//turning right
			{
				motor[right] = motor[right] + 1;
			}
			if(SensorValue(gyro) < offset)	//turning left
			{
				motor[left] = motor[left] + 1;
			}
			gyroed = true;
		}

		if(joystick.joy1_TopHat == 4)
		{
			motor[right] = -75;
			motor[left] = -75;
		}

		//	Turn on the gyro stabilization backwards, ask Ethan
		while(joystick.joy1_TopHat == 4)
		{
			getJoystickSettings(joystick);
			if(SensorValue(gyro) > offset)	//turning right
			{
				motor[right] = motor[right] - 1;
			}
			if(SensorValue(gyro) < offset)	//turning left
			{
				motor[left] = motor[left] - 1;
			}
			gyroed = true;
		}

		if(joystick.joy1_TopHat == 6)
		{
			turnDegrees(gyro, left, 70, 75);
		}

		if(joystick.joy1_TopHat == 2)
		{
			turnDegrees(gyro, right, 70, 75);
		}

		//	Reset gyro stuff
		if(gyroed)
		{
			motor[left] = 0;
			motor[right] = 0;
			gyroed = false;
		}

		if(joystick.joy1_y1 == lastJoyVal && joystick.joy1_y1 != 0)//detect loss of connection
		{
			cycles ++;
		}
		else
		{
			cycles = 0;
			lastJoyVal = joystick.joy1_y1;
		}

		if(cycles == 32767)//shut off motors if we lose connection
		{
			motor[left] = 0;
			motor[right] = 0;
			motor[slide] = 0;
			joystick.joy1_y1 = 0;
			joystick.joy1_y2 = 0;
			cycles = 0;
		}

		if (joy1Btn(3))
		{
			servo[gripper] == 255 ? 0 : 255;
		}
		
	}//end while loop
}//end task main
