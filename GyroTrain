#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Hubs,  S2, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S4,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Motor,  mtr_S1_C1_1,     frontRight,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     frontLeft,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C1_1,     slide,             tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     intake,             tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "DriverCM.h"
bool gyroed;
int servoVal = 0;

int speedCurve(int x)
{
	float speed = 0.0000216166*pow(x,3)+1.19001*pow(10,-18)*pow(x,2)+0.427083*x;
	return speed;
}

task main()
{
	calibrateGyro(gyro);
	while(true)
	{
		getJoystickSettings(joystick);

		/*Drive code*/
		motor[frontLeft] = speedCurve(joystick.joy1_y2);
		motor[frontRight] = speedCurve(joystick.joy1_y1);
		if(joy1Btn(6))//bumpers for slide
		{
			motor[slide] = 50;
		}
		else if(joy1Btn(5))
		{
			motor[slide] = -25;
		}
		else
		{
			motor[slide] = 0;
		}

		if(joy1Btn(7))//triggers for intake
		{
			motor[intake] = 100;
		}
		else if(joy1Btn(4))
		{
			motor[intake] = -100;
		}
		else
		{
			motor[intake] = 0;
		}

		while(joystick.joy1_TopHat == 4)
		{
		getJoystickSettings(joystick);
		if(SensorValue(gyro) > offset)//turning right
		{
			motor[frontRight] = motor[frontRight] - 1;
		}
		if(SensorValue(gyro) < offset)//turning left
		{
			motor[frontLeft] = motor[frontLeft] - 1;
		}
		gyroed = true;
		}//end gyro code
		if(gyroed)
		{
			motor[frontLeft] = 1;
			motor[frontRight] = 1;
			gyroed = false;
		}
	}
}
